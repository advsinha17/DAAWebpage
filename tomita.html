---
---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>Enumeration of Maximal Cliques</title>
    <meta name="generator" content="Jekyll v4.4.1" />
    <meta property="og:title" content="Enumeration of Maximal Cliques" />
    <meta property="og:locale" content="en_US" />
    <link rel="canonical" href="https://advsinha17.github.io/DAAPage/" />
    <meta property="og:url" content="https://advsinha17.github.io/DAAPage/" />
    <meta property="og:site_name" content="Enumeration of Maximal Cliques" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Enumeration of Maximal Cliques" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "headline": "Enumeration of Maximal Cliques",
        "name": "Enumeration of Maximal Cliques",
        "url": "https://advsinha17.github.io/DAAPage/"
      }
    </script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- End Jekyll SEO tag -->
    <link rel="stylesheet" href="/DAAPage/assets/main.css" />
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://advsinha17.github.io/DAAPage/feed.xml"
      title="Enumeration of Maximal Cliques"
    />
  </head>
  <body>
    <header class="site-header" role="banner">
      <div class="wrapper">
        <a class="site-title" rel="author" href="/DAAPage/"
          >Design and Analysis of Algorithms - Assignment 1</a
        >
        <nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path
                  d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"
                />
              </svg>
            </span>
          </label>

          <div class="trigger"></div>
        </nav>
      </div>
    </header>
    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">
          <!-- # Enumeration of Maximal Cliques

The following 3 algorithms were implemented to enumerate the maximal cliques in a graph:

- [Bron Kerbosch Algorithm](/bka)
- [Chiba](/chiba)
- [Tomita](/tomita) -->

          <br />
          <br />
          <br />

          <div align="center" class="container">
            <img src="cliques.png" alt="Site Logo" class="logo" width="100px" />
          </div>

          <h1 style="font-size: 3rem" align="center">
            Enumeration of Maximal Cliques
          </h1>
          <hr style="border: 0.5px solid #ddd; margin: 10px 0" />
          <nav class="menu">
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                display: flex;
                justify-content: center;
                align-items: center;
              "
            >
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Problem Statement</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>

              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/bka"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Bron-Kerbosch</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/chiba"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Chiba</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/tomita"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Tomita</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/datasets"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Datasets</a
                >
              </li>
            </ul>
          </nav>
          <hr style="border: 0.5px solid #ddd; margin: 10px 0" />

          <br />
          <br />
          <br />

          <h1 align="center">CLIQUE Algorithm</h1>
            <p align="center" style="padding-left: 1rem; padding-top: 5px">
              üìÅ
              <a href="https://www.sciencedirect.com/science/article/pii/S0304397506003586"
                >Paper Link</a
              >
            </p>

          <h2 align="center">Algorithm Description</h2>

          <p class="algoText" align="center">
            The CLIQUE algorithm by
            <a href="https://www.sciencedirect.com/science/article/pii/S0304397506003586">Tomita et. al.</a> is a depth-first search
            algorithm that finds all maximal cliques in an undirected graph.
            The CLIQUE algorithm uses 3 sets of vertices:<br />
            <ul>
              <li><i>SUBG</i>: the set of vertices currently being considered as part of the subgraph for finding maximal cliques</li>
              <li><i>Q</i>: the current clique</li>
              <li><i>CAND</i>: the set of vertices that are potential candidates to extend the current clique</li>
            </ul>
          </p>

          <p class="algoText" align="center">
            Initially, both <i>SUBG</i> and <i>CAND</i> are equal to <i>V</i>, the set of all vertices, and set <i>Q</i> is empty. The algorithm recursively
            expands <i>Q</i> to search for larger and larger complete subgraphs until they reach maximum ones. IF <i>SUBG</i> is empty, then 
            <i>Q</i> is a maximal clique.
             <br /><br />
             The algorithm uses two pruning techniques to minimize the number of recursive calls made. First, let <i>FINI</i> be the set of 
             vertices of <i>SUBG</i> that have already been processed. Then the remaining candidates for expansion are <i>CAND = SUBG - FINI</i>. For a vertex
             <i>q</i>, let <i>SUBG<sub>q</sub></i> be the set of vertices that are in the intersection of <i>SUBG</i> and the neighbors of <i>q</i>. Then only the vertices
             in <i>CAND<sub>q</sub></i> are considered to expand the complete subgraph <i>Q</i> ‚à™ {<i>q</i>} as all the cliques containing (<i>Q</i> ‚à™ {<i>q</i>}) ‚à™ {<i>r</i>} with <i>r</i> ‚àà <i>FINI<sub>q</sub></i>
             have already been generated.
             <br /><br />
             The second pruning method describes the best way to select the pivot element in each recursive call. From the previous pruning method, the 
             only search trees to be expanded are from the vertices in <i>(SUBG ‚àí SUBG ‚à© Œì(u)) ‚àí FINI = CAND ‚àí Œì(u)</i>. Hence, the pivot element is chosen
             as the one that maximizes <i>|CAND ‚à© Œì(u)|</i>.
             <br /><br />
     
             The algorithm initializes both <i>SUBG</i> and <i>CAND</i> to  <i>V</i>, the set of all vertices and <i>Q</i> to the empty set. It then
             calls the <i>EXPAND</i> method. In the expand method, if SUBG is empty, the algorithm reports <i>Q</i> as a maximal clique.
             Otherwise, it calculates the pivot element <i>u</i> from <i>SUBG</i> to maximize <i>|CAND ‚à© Œì(u)|</i>. It then iterates over the vertices
             in <i>CAND ‚àí Œì(u)</i> and recursively calls the <i>EXPAND</i> method with the updated <i>SUBG</i> and <i>CAND</i> sets. For a vertex 
             <i>v</i> in <i>CAND ‚àí Œì(u)</i>, it makes a recursive call with <i>CAND</i> as the intersection of <i>Œì(v)</i> and <i>CAND</i>, and <i>SUBG</i> 
             as the intersection of <i>Œì(v)</i> and <i>SUBG</i>. The element <i>v</i> is added to set <i>Q</i>. After the recursive call, <i>v</i> is removed from <i>CAND</i>.
             <br /><br />
             The pseudocode for the CLIQUE algorithm is as follows:
           </p>

           <pre class="codeBlock">
            <code>
                procedure CLIQUES(G)
                    /* Graph G = (V, E) * / 
                    begin
                    Q := Œ¶;
                    /* global variable Q is to constitute a clique */
                    EXPAND(V, V)
                end of CLIQUES
    
                procedure EXPAND(SUBG, CAND)
                    begin
                    if SUBG = Œ¶ 
                        then print ("clique,")
                        /* to represent that Q is a maximal clique */
                    else u := a vertex in SUBG that maximizes |CAND ‚à© Œì(u)|;
                    /* let EXT_u = CAND - Œì(u); */
                    /* FINI := Œ¶; */
                    while CAND - Œì(u) ‚â† Œ¶
                        do q := a vertex in (CAND - Œì(u));
                            print (q, ",");
                            /* to represent the next statement */
                            /* Q := Q ‚à™ {q};  */
                            SUBG<sub>q</sub> := SUBG ‚à© Œì(q);
                            CAND<sub>q</sub> := CAND ‚à© Œì(q);
                            EXPAND(SUBG<sub>q</sub>, CAND<sub>q</sub>);
                            CAND := CAND - {q}; /* FINI := FINI ‚à™ {q}; */
                            print ("back,");
                            /* to represent the next statement */
                            /* Q := Q - {q} */
                        od
                    fi
                end of EXPAND
            </code>
          </pre>

          <p class="algoText" align="center">
            <b>Time Complexity of the Algorithm:</b> <i>O(3<sup>n/3</sup>)</i>,
            where <i>n</i> is the number of vertices in the graph.
          </p>

          <br />
          <h2 class="experimental" align="center">
            Implementation details and Experimental Observations
          </h2>
          <p class="algoText" align="center">
            The algorithm was run on an M1 MacBook Air with 16GB RAM and using the
            -O3 optimization flag during compilation. The algorithm was run on the
            Enron email network, Autonomous systems by Skitter, and Wikipedia vote
            network datasets. The Email enron network took <b>1.94 seconds</b>, the Autonomous systems by
            Skitter took <b>360 seconds (6 minutes)</b>, and the
            Wikipedia vote network took <b>2.39 seconds</b> to run the algorithm.<br /><br />
          </p>
          <div class="container">
            <div id="runtimeBarChart"></div>
          </div>
          <p class="algoText" style="padding-bottom: 40px" align="center">
            The graph was stored as an adjacency list using a vector of sets, to
            allow for efficient search of neighbors of a vertex. To store the sets<i>SUBG</i> and 
            <i>CAND</i>, we experimented with different data structures. When using vectors, we found that 
            the search for an element within the vector was becoming a bottleneck for our preformance.
            To improve this, we attempted to use a 0/1 hash vector along side the original vectors to facilitate
            efficient search as well as iteration. However, for larger datasets, this led to an increase in the memeory
            requirement of the program and hampered performance.
            We found that using an unordered set for <i>SUBG</i> and <i>CAND</i> was the most efficient, as it provides
            an efficient way to search for elements.
            <br /><br />
            Another optimization we implemented was to minimize the number of iterations while finding the pivot element. For this, 
            we checked which set between <i>CAND</i> and the neighbors set is smaller, so that the loop iterates over fewer elements. We also implemented
            this optimization while computing the sets <i>SUBG<sub>q</sub></i> and <i>CAND<sub>q</sub></i>, which we found significantly improves the running
            time of the algorithm.
          </p>

          <h2 class="experimental" align="center">
            Algorithm Implementation
          </h2>
          <p align="center">üîó The algorithm implementation and execution instructions can be found <a href="https://github.com/advsinha17/DAA-Assignments/tree/master/Assignment1">here</a>.</p>
           <pre class="codeBlock">
            <code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;unordered_set&gt;
#include &lt;set&gt;
#include &lt;chrono&gt;
using namespace std;


long long count_cliques = 0;
long long max_size = 0;

void expand(unordered_set&lt;int&gt; &subg, unordered_set&lt;int&gt; &cand,vector&lt;set&lt;int&gt; &gt; &adj, vector&lt;int&gt;& Q, int n, unordered_map&lt;int, int&gt; &distribution){
    if(subg.empty()){
        distribution[(int)Q.size()]++;
        count_cliques++;
        max_size = max(max_size, (long long)Q.size());
        return;
    }
    int pivot = -1;
    int pivotSize = -1;
    for (auto i: subg) {
        int count = 0;
        if (adj[i].size() &lt; cand.size()) {
            for (auto y: adj[i]) {
                if (cand.find(y) != cand.end()) count++;
            }
        } else {
            for (auto y: cand) {
                if (adj[i].find(y) != adj[i].end()) count++;
            }
        }

        if (count &gt; pivotSize) {
            pivot = i;
            pivotSize = count;
        }
    }
    for (auto it = cand.begin(); it != cand.end(); ) {
        int x = *it;
        if (adj[pivot].find(x) != adj[pivot].end()) {
            ++it;
            continue;
        } 
        unordered_set&lt;int&gt; newSubg;
        unordered_set&lt;int&gt; newCand;
        if (cand.size() &lt; adj[x].size()) {
            for (auto y: cand) {
                if (adj[x].find(y) != adj[x].end()) newCand.insert(y);
            }
        } else {
            for (auto y: adj[x]) {
                if (cand.find(y) != cand.end()) newCand.insert(y);
            }
        }
        
        if (subg.size() &lt; adj[x].size()) {
            for (auto y: subg) {
                if (adj[x].find(y) != adj[x].end()) newSubg.insert(y);
            }
        } else {
            for (auto y: adj[x]) {
                if (subg.find(y) != subg.end()) newSubg.insert(y);
            }
        }
        Q.push_back(x);
        expand(newSubg, newCand, adj, Q, n, distribution);
        Q.pop_back();
        it = cand.erase(it);
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Correct Usage: %s &lt;dataFilePath&gt;\n", argv[0]);
        exit(1);
    }
    auto start = chrono::high_resolution_clock::now();

    string filename = argv[1];
    ifstream infile(filename);
    if (!infile.is_open()) {
        cerr &lt;&lt; "Error opening file" &lt;&lt; endl;
        return 1;
    }

    string line;
    int n = 0, m = 0;
    vector&lt;set&lt;int&gt;&gt; adj;
    unordered_map&lt;int, int&gt; vertexMap;  
    int nextIndex = 0;       

    while (getline(infile, line)) {
        if (line.empty() || line[0] == '#') {
            if (line.find("Nodes:") != string::npos) {
                size_t pos = line.find("Nodes:");
                if (pos != string::npos) {
                    n = stoi(line.substr(pos + 7));
                }
            }
            if (line.find("Edges:") != string::npos) {
                size_t pos = line.find("Edges:");
                if (pos != string::npos) {
                    m = stoi(line.substr(pos + 7));
                }
            }
            continue;
        }

        if (n == 0 || m == 0) {
            continue;
        }

        istringstream iss(line);
        int u, v;
        if (!(iss &gt;&gt; u &gt;&gt; v)) {
            continue;
        }

        if (vertexMap.find(u) == vertexMap.end()) {
            vertexMap[u] = nextIndex;
            nextIndex++;
        }
        if (vertexMap.find(v) == vertexMap.end()) {
            vertexMap[v] = nextIndex;
            nextIndex++;
        }

        if (adj.size() &lt; n) {
            adj.resize(n);
        }

        int mappedU = vertexMap[u];
        int mappedV = vertexMap[v];

        adj[mappedU].insert(mappedV);
        adj[mappedV].insert(mappedU);
    }

    infile.close();

    unordered_set&lt;int&gt; subg(n);
    unordered_set&lt;int&gt; cand(n);
    unordered_map&lt;int, int&gt; distribution;
    for (int i = 0; i &lt; n; i++) {;
        subg.insert(i);
        cand.insert(i);
    }
    vector&lt;int&gt; Q;
    expand(subg, cand, adj, Q, n, distribution);

    cout &lt;&lt; "Number of cliques: " &lt;&lt; count_cliques &lt;&lt; endl;
    cout &lt;&lt; "Size of largest maximal clique: " &lt;&lt; max_size &lt;&lt; endl;
    auto end = chrono::high_resolution_clock::now();
    cout &lt;&lt; endl;
    cout &lt;&lt; "Distribution of clique sizes:" &lt;&lt; endl;
    cout &lt;&lt; "Size Number of cliques" &lt;&lt; endl;
    for (auto x: distribution) {
        cout &lt;&lt; x.first &lt;&lt; "    " &lt;&lt; x.second &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
    chrono::duration&lt;double&gt; duration = end - start;
    cout &lt;&lt; "Time taken by algorithm: " &lt;&lt; duration.count() &lt;&lt; " seconds" &lt;&lt; endl;
    return 0;
}

</code>
              </pre>
          <script>
            const datasets = [
              "Enron Email",
              "Autonomous systems",
              "Wikipedia vote",
            ];
    
            const runtimes = [1.94, 360, 2.39];
    
            const data = [
              {
                x: datasets,
                y: runtimes,
                type: "bar",
                marker: {
                  color: "blue",
                },
              },
            ];
    
            const layout = {
              title: "Runtime by Dataset",
              xaxis: {
                title: "Dataset Name",
                tickangle: -45,
              },
              yaxis: {
                title: "Runtime (s)",
                titlefont: { size: 14 },
              },
              margin: { b: 200, t: 150 },
            };
    
            Plotly.newPlot("runtimeBarChart", data, layout);
          </script>



        </div>
      </div>
    </main>
  </body>
</html>
