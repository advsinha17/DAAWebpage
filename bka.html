---
---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>Enumeration of Maximal Cliques</title>
    <meta name="generator" content="Jekyll v4.4.1" />
    <meta property="og:title" content="Enumeration of Maximal Cliques" />
    <meta property="og:locale" content="en_US" />
    <link rel="canonical" href="https://advsinha17.github.io/DAAPage/" />
    <meta property="og:url" content="https://advsinha17.github.io/DAAPage/" />
    <meta property="og:site_name" content="Enumeration of Maximal Cliques" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Enumeration of Maximal Cliques" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "headline": "Enumeration of Maximal Cliques",
        "name": "Enumeration of Maximal Cliques",
        "url": "https://advsinha17.github.io/DAAPage/"
      }
    </script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- End Jekyll SEO tag -->
    <link rel="stylesheet" href="/DAAPage/assets/main.css" />
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://advsinha17.github.io/DAAPage/feed.xml"
      title="Enumeration of Maximal Cliques"
    />
  </head>
  <body>
    <header class="site-header" role="banner">
      <div class="wrapper">
        <a class="site-title" rel="author" href="/DAAPage/"
          >Design and Analysis of Algorithms - Assignment 1</a
        >
        <nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path
                  d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"
                />
              </svg>
            </span>
          </label>

          <div class="trigger"></div>
        </nav>
      </div>
    </header>
    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">
          <!-- # Enumeration of Maximal Cliques

The following 3 algorithms were implemented to enumerate the maximal cliques in a graph:

- [Bron Kerbosch Algorithm](/bka)
- [Chiba](/chiba)
- [Tomita](/tomita) -->

          <br />
          <br />
          <br />

          <div align="center" class="container">
            <img src="cliques.png" alt="Site Logo" class="logo" width="100px" />
          </div>

          <h1 style="font-size: 3rem" align="center">
            Enumeration of Maximal Cliques
          </h1>
          <hr style="border: 0.5px solid #ddd; margin: 10px 0" />
          <nav class="menu">
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                display: flex;
                justify-content: center;
                align-items: center;
              "
            >
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Problem Statement</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>

              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/bka"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Bron-Kerbosch</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/chiba"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Chiba</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/tomita"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Tomita</a
                >
              </li>
              <li style="display: inline; margin: 0 10px">|</li>
              <li style="display: inline; margin: 0 10px">
                <a
                  href="/DAAPage/datasets"
                  style="text-decoration: none; font-weight: semi-bold"
                  >Datasets</a
                >
              </li>
            </ul>
          </nav>
          <hr style="border: 0.5px solid #ddd; margin: 10px 0" />

          <br />
          <br />
          <br />

          <h1 align="center">Bron-Kerbosch Algorithm</h1>
            <p align="center" style="padding-left: 1rem; padding-top: 5px">
              üìÅ
              <a href="https://arxiv.org/abs/1006.5440"
                >Paper Link</a
              >
            </p>

          <h2 align="center">Algorithm Description</h2>
          

          <p align = "center" class="algoText">
            The Bron-Kerbosch algorithm is a backtracking algorithm to find all
        maximal cliques in a graph. Each maximal clique can be listed in
        polynomial time. However, the maximum possible number of cliques is
        exponential, leading to an exponential complexity for enumeration of all
        maximal cliques. To overcome this, the paper by
        <a href="https://arxiv.org/abs/1006.5440">David et. al.</a> showed that
        a parameterized variant of the Bron-Kerbosch algorithm, parameterized by
        degeneracy of a graph enumerates all maximal cliques in graphs of
        constant degeneracy in linear time w.r.t the number of vertices in the
        graph. The degeneracy of an <i>n</i>-vertex graph is the smallest number d such that every subgraph of G contains a vertex of at most d.<br /><br />
        The Bron-Kerbosch algorithm uses 3 disjoint sets of vertices:<br />
            <ul style="padding-left: 80px;">
              <li>P: the set of vertices to be included in the current clique</li>
              <li>R: the current clique</li>
              <li>X: the set of vertices that are not yet included in the current clique</li>
            </ul>
          </p>

          <p class="algoText" align="center">
             R is clique such that P ‚à™ X = Œì(R) are the vertices adjacent to every vertex 
              in R. The algorithm will choose an element <i>v</i> from P to add to the 
              clique and make a recursive call after moving <i>v</i> from P to R. 
              When this recursive call completes, the element <i>v</i> will be moved 
              to X to eliminate redundant calls. The algorithm uses the concept of pivoting 
              to limit the number of recursive calls. It follows the pivoting method described 
              by <a href="https://snap.stanford.edu/class/cs224w-readings/tomita06cliques.pdf">Tomita et. al.</a> which chooses pivot <i>u</i> from P ‚à™ X in order
              to maximize |P ‚à© Œì(u)|.
              <br /><br />
              The algorithm first computes a degeneracy ordering of the given graph. It 
              then iterates over the vertices in the degeneracy ordering, and for each
              vertex <i>v<sub>i</sub></i> in the ordering, it computes the sets P as the 
              intersection of the vertices which come after <i>v<sub>i</sub></i> in the ordering and the neighbours of <i>v<sub>i</sub></i>.
              The set X is computed as the intersection of the vertices which come before <i>v<sub>i</sub></i> in the ordering and the neighbours of <i>v<sub>i</sub></i>.  
              The set R contains only the vertex <i>v<sub>i</sub></i>. Then it calls the Bron-Kerbosch with pivoting function
              for inner calls of the algorithm.
              <br /><br />
              In the Bron-Kerbosch pivot function, if P and X are empty, the algorithm reports R as a maximal clique. Otherwise, 
              the algorithm computes a pivot <i>u</i> from  P ‚à™ X in order to maximize |P ‚à© Œì(u)|.
              The algorithm then iterates over the vertices in <i>P \ Œì(u)</i> and computes the sets P and X for the next recursive call.
              For a vertex <i>v</i> in <i>P \ Œì(u)</i>, the algorithm makes a recursive call with P as the intersection of Œì(v) and P, R as the union of R and {v}, and X as the intersection of Œì(v) and X.
              After the recursive call, the algorithm removes the vertex <i>v</i> from P and adds it to X.
              <br /><br />
              The psuedocode for the Bron-Kerbosch pivoting algorithm is as follows:
          </p>

          <pre class="codeBlock" style="padding-left: 0;">
            <code>
    proc BronKerboschPivot(P, R, X)
      if P ‚à™ X = Œ¶ then
        report R as a maximal clique
      end if
      choose a pivot u ‚àà P ‚à™ X {Tomita et al. choose u to maximize |P ‚à© Œì(u)|}
      for each vertex v ‚àà P\Œì(u) do
        BronKerboschPivot(P ‚à© Œì(v), R ‚à™ {v}, X ‚à© Œì(v))
        P ‚Üê P\ {v}
        X ‚Üê X ‚à™ {v}
      end for
            </code>
          </pre>

          <p class="algoText" align="center">
            The top level of recursion is done using the following code:
          </p>
          <pre class="codeBlock">
            <code>
    proc BronKerboschDegeneracy(V, E)
      for each vertex <i>v<sub>i</sub></i>

      in a degeneracy ordering <i>v<sub>0</sub></i>, <i>v<sub>1</sub></i>, <i>v<sub>2</sub></i>, . . . of (V,E) do
        P ‚Üê Œì (<i>v<sub>i</sub></i>) ‚à© {<i>v<sub>i + 1</sub></i>,..., <i>v<sub>n - 1</sub></i>}
        X ‚Üê Œì (<i>v<sub>i</sub></i>) ‚à© {<i>v<sub>0</sub></i>,..., <i>v<sub>i - 1</sub></i>}
        BronKerboschPivot(P, {<i>v<sub>i</sub></i>}, X)
      end for
            </code>
          </pre>
          <p class="algoText" align="center">
            <b>Time Complexity of the Algorithm:</b> <i>O(dn3<sup>d/3</sup>)</i>,
            where <i>d</i> is the degeneracy of the graph.
          </p>

          <br />
        

          <h2 class="experimental" align="center">
            Implementation details and Experimental Observations
          </h2>
          <p class="algoText" align="center">
            The algorithm was run on an M1 MacBook Air with 16GB RAM and using the
            -O3 optimization flag during compilation. The algorithm was run on the
            Enron email network, Autonomous systems by Skitter, and Wikipedia vote
            network datasets. The Email
            enron network took <b>1.13 seconds</b>, the Autonomous systems by
            Skitter took <b>213 seconds (3 minutes, 33 seconds)</b>, and the
            Wikipedia vote network took <b>1.51 seconds</b> to run the algorithm.<br /><br />
          </p>
          <div class="container">
            <div id="runtimeBarChart"></div>
          </div>
          <p class="algoText" style="padding-bottom: 40px" align="center">
            The graph was stored as an adjacency list using a vector of sets, to
        allow for efficient search of neighbors of a vertex. We experimented
        with different methods to store the P and X sets in the Bron-Kerbosch
        algorithm. Initially, we tried to use unordered sets to P and X as the find operation in unordered sets is constant time in the average case due to the hashing of elements. 
        However, as P and X became large, the number of collisions increased leading to decreased performance of the algorithm. We found that implementing both P and X as vectors was the
        most efficient, as these are stored contiguously in memory, and are stored in cache leading to efficient performance of the algorithm.
        
        <br />
        Further, to find the pivot element, we found that
        iterating over the elements of P to determine the intersection
        significantly improved the running time, likely due to the fact that P
        often contains few elements, thus leading to fewer iterations of the
        loop. 
        <br /><br />
        We attempted to optimize the algorithm by making use of a 0/1 hash table to implement the sets P and X. 
        Doing this allowed us to perform searches for elements in P or X in constant time. However, the overhead 
        of storing and creating the hash table for large datasets hampered the performance of the algorithm.
        <br /><br />
            
          </p>
          <h2 class="experimental" align="center">
            Algorithm Implementation
          </h2>
          <p align="center">üîó The algorithm implementation and execution instructions can be found <a href="https://github.com/advsinha17/DAA-Assignments/tree/master/Assignment1">here</a>.</p>
          <pre class="codeBlock">
            <code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;unordered_set&gt;
using namespace std;

long long count_cliques = 0;
long long max_size = 0;


int getDegeneracy(vector&lt;set&lt;int&gt;&gt; &adj, vector&lt;int&gt;& degeneracyOrder, int n) {
    vector&lt;int&gt; degrees(n);
    for (int i = 0; i &lt; n; i++) {
        degrees[i] = adj[i].size();
    }
    vector&lt;vector&lt;int&gt;&gt; D(n);
    for (int i = 0; i &lt; n; i++) {
        D[degrees[i]].push_back(i);
    }
    int i = 0; 
    int num = 0;
    int degeneracy = 0;
    vector&lt;bool&gt; removed(n, false);
    while (num &lt; n) {
        while (D[i].empty()) i++;
        int x = D[i].front();
        D[i].erase(D[i].begin());
        degeneracyOrder[num++] = x;
        degeneracy = max(degeneracy, i);
        removed[x] = true;
        for (auto y: adj[x]) {
            if (!removed[y]) {
                int oldDegree = degrees[y];
                degrees[y]--;
                auto it = find(D[oldDegree].begin(), D[oldDegree].end(), y);
                if (it!= D[oldDegree].end()) {
                    D[oldDegree].erase(it);
                }
                
                D[degrees[y]].push_back(y);
            }
        }
        i = 0;
    }
    return degeneracy;
}
void BronKerboschPivot(vector&lt;int&gt; &P, vector&lt;int&gt; &R, vector&lt;int&gt; &X, vector&lt;set&lt;int&gt;&gt; &adj, int n, unordered_map&lt;int, int&gt; &distribution) {
    if (P.empty() && X.empty()) {
        distribution[(int)R.size()]++;
        count_cliques++;
        max_size = max(max_size, (long long)R.size());
        return;
    }
    int pivot = -1;
    int pivotSize = -1;
    for (auto i: P) {
        int count = 0;
        for (auto y: P) {
            if (adj[i].find(y) != adj[i].end()) count++;
        }
        if (count &gt; pivotSize) {
            pivot = i;
            pivotSize = count;
        }
        
    }
    for (auto i: X) {
        int count = 0;
        for (auto y: P) {
            if (adj[i].find(y) != adj[i].end()) count++;
        }
        if (count &gt; pivotSize) {
            pivot = i;
            pivotSize = count;
        }
    }
    for (auto it = P.begin(); it != P.end();) {
        int i = *it;  

        if (adj[pivot].find(i) != adj[pivot].end()) {
            it++;
            continue;
        }
        vector&lt;int&gt; intersectP;
        vector&lt;int&gt; intersectX;
        for (auto y: P) {
            if (adj[i].find(y) != adj[i].end()) intersectP.push_back(y);
        }
        for (auto y: X) {
            if (adj[i].find(y) != adj[i].end()) intersectX.push_back(y);
        }

        R.push_back(i);
        BronKerboschPivot(intersectP, R, intersectX, adj, n, distribution);
        R.pop_back();
        X.push_back(i);
        it = P.erase(it);
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Correct Usage: %s &lt;dataFilePath&gt;\n", argv[0]);
        exit(1);
    }
    auto start = chrono::high_resolution_clock::now();

    string filename = argv[1];
    ifstream infile(filename);
    if (!infile.is_open()) {
        cerr &lt;&lt; "Error opening file" &lt;&lt; endl;
        return 1;
    }

    string line;
    int n = 0, m = 0;
    vector&lt;set&lt;int&gt;&gt; adj;
    vector&lt;int&gt; degrees;
    unordered_map&lt;int, int&gt; vertexMap; 
    int nextIndex = 0;       

    while (getline(infile, line)) {
        if (line.empty() || line[0] == '#') {
            if (line.find("Nodes:") != string::npos) {
                size_t pos = line.find("Nodes:");
                if (pos != string::npos) {
                    n = stoi(line.substr(pos + 7));
                }
            }
            if (line.find("Edges:") != string::npos) {
                size_t pos = line.find("Edges:");
                if (pos != string::npos) {
                    m = stoi(line.substr(pos + 7));
                }
            }
            continue;
        }

        if (n == 0 || m == 0) {
            continue;
        }

        istringstream iss(line);
        int u, v;
        if (!(iss &gt;&gt; u &gt;&gt; v)) {
            continue;
        }

        if (vertexMap.find(u) == vertexMap.end()) {
            vertexMap[u] = nextIndex;
            nextIndex++;
        }
        if (vertexMap.find(v) == vertexMap.end()) {
            vertexMap[v] = nextIndex;
            nextIndex++;
        }

        if (adj.size() &lt; n) {
            adj.resize(n);
            degrees.resize(n, 0);
        }

        int mappedU = vertexMap[u];
        int mappedV = vertexMap[v];

        adj[mappedU].insert(mappedV);
        adj[mappedV].insert(mappedU);
    }

    infile.close();
    vector&lt;int&gt; degeneracyOrder(n, -1);
    int degeneracy = getDegeneracy(adj, degeneracyOrder, n);
    unordered_map&lt;int, int&gt; distribution;


    // BronKerboschDegeneracy Algorithm
    vector&lt;int&gt; R;
    unordered_set&lt;int&gt; completed;
    for (int t = 0; t &lt; n; t++) {
        int i = degeneracyOrder[t];
        vector&lt;int&gt; P;
        vector&lt;int&gt; X;
        for (auto x: adj[i]) {
            if (completed.find(x) != completed.end()) {
                X.push_back(x);
            } else P.push_back(x);
        }
        R.push_back(i);
        BronKerboschPivot(P, R, X, adj, n, distribution);
        R.pop_back();
        completed.insert(i);
    }

    cout &lt;&lt; "Number of cliques: " &lt;&lt; count_cliques &lt;&lt; endl;
    cout &lt;&lt; "Size of largest maximal clique: " &lt;&lt; max_size &lt;&lt; endl;

    auto end = chrono::high_resolution_clock::now();
    cout &lt;&lt; endl;
    cout &lt;&lt; "Distribution of clique sizes:" &lt;&lt; endl;
    cout &lt;&lt; "Size Number of cliques" &lt;&lt; endl;
    for (auto x: distribution) {
        cout &lt;&lt; x.first &lt;&lt; "    " &lt;&lt; x.second &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
    chrono::duration&lt;double&gt; duration = end - start;
    cout &lt;&lt; "Time taken by algorithm: " &lt;&lt; duration.count() &lt;&lt; " seconds" &lt;&lt; endl;


    return 0;
}

        </code>
          </pre>



          <script>
            const datasets = [
              "Enron Email",
              "Autonomous systems",
              "Wikipedia vote",
            ];
    
            const runtimes = [1.13, 213, 1.51];
    
            const data = [
              {
                x: datasets,
                y: runtimes,
                type: "bar",
                marker: {
                  color: "blue",
                },
              },
            ];
    
            const layout = {
              title: "Runtime by Dataset",
              xaxis: {
                title: "Dataset Name",
                tickangle: -45,
              },
              yaxis: {
                title: "Runtime (s)",
                titlefont: { size: 14 },
              },
              margin: { b: 200, t: 150 },
            };
    
            Plotly.newPlot("runtimeBarChart", data, layout);
          </script>
        </div>
      </div>
    </main>
  </body>
</html>

